<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>K-Tetris</title>
  <style>
    :root{
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --stroke: rgba(255,255,255,.18);
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --radius: 18px;
      --glass: rgba(10,10,20,.55);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color:var(--txt); }
    body{
      background:#05040a;
      -webkit-tap-highlight-color: transparent;
      overflow:hidden;
      touch-action: none;
    }

    .wrap{
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:
        calc(14px + env(safe-area-inset-top))
        14px
        calc(14px + env(safe-area-inset-bottom))
        14px;
    }

    /* Card singola */
    .panel{
      width: min(980px, 100%);
      background: linear-gradient(180deg, rgba(20,16,40,.60), rgba(10,10,20,.60));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      overflow: visible; /* IMPORTANT: evita ‚Äúmangiato‚Äù in alto */
    }

    .header{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px;
      padding: 16px 16px 12px 16px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: linear-gradient(90deg, rgba(255,120,230,.18), rgba(120,170,255,.16), rgba(255,255,255,.04));
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
    }
    .title h1{
      margin:0;
      font-size: 18px;
      letter-spacing:.2px;
      line-height:1.05;
    }
    .title p{
      margin:6px 0 0;
      font-size: 12px;
      color: var(--muted);
      line-height:1.25;
    }
    .badge{
      display:flex; flex-direction:column; align-items:flex-end; gap:6px;
      min-width: 170px;
      padding-top: 2px;
    }
    .pill{
      font-size:12px;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      white-space:nowrap;
    }
    .progress{
      width:100%;
      height:10px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      overflow:hidden;
    }
    .bar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(255,120,230,.85), rgba(120,170,255,.85));
      transition: width 250ms ease;
    }

    /* Game layout: canvas + side stats (sempre dentro panel) */
    .gameArea{
      display:flex;
      gap:14px;
      padding:14px;
      align-items:stretch;
      justify-content:center;
      flex-wrap:wrap; /* su schermi piccoli va sotto senza tagliare */
    }

    /* STAGE: sfondo SOLO dietro griglia */
    .stage{
      position:relative;
      width: min(420px, 78vw); /* spazio canvas su iPhone 8 */
      aspect-ratio: 10 / 20;
      border-radius: 14px;
      overflow:hidden; /* ritaglia lo sfondo al solo stage */
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
      flex: 0 0 auto;
    }

    .gameBg{
      position:absolute; inset:0;
      background-image: url("bg1.png");
      background-size: cover;         /* adattamento */
      background-position: center;    /* centrato */
      background-repeat: no-repeat;
      transform: scale(1.04);
      filter: saturate(1.15) contrast(1.05) brightness(.88);
      transition: opacity 700ms ease;
    }
    .gameBg::after{
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(900px 500px at 50% 25%, rgba(255,170,255,.18), transparent 60%),
        linear-gradient(to bottom, rgba(0,0,0,.40), rgba(0,0,0,.65));
      pointer-events:none;
    }
    .gameBg.alt{
      background-image: url("bg2.png");
      opacity:0;
    }

    canvas{
      position:absolute; inset:0;
      width:100%;
      height:100%;
      display:block;
      background: rgba(0,0,0,.20); /* trasparente ma leggibile */
    }

    .side{
      display:flex;
      flex-direction:column;
      gap: 12px;
      min-width: 240px;
      max-width: 320px;
      flex: 1 1 260px;
    }

    .statGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .stat{
      padding: 12px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
    }
    .stat .k{ font-size:11px; color:var(--muted); }
    .stat .v{ font-size:20px; margin-top:4px; font-weight:700; letter-spacing:.2px; }

    .hint{
      padding: 12px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      color: rgba(255,255,255,.82);
      line-height:1.35;
    }
    .hint b{ color: rgba(255,255,255,.95); }

    .controls{
      padding: 12px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 10px;
    }
    .btn{
      user-select:none;
      -webkit-user-select:none;
      display:flex; align-items:center; justify-content:center;
      padding: 12px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.12);
      color: rgba(255,255,255,.95);
      font-weight:700;
      font-size: 14px;
      box-shadow: 0 10px 22px rgba(0,0,0,.22);
      cursor:pointer;
      transition: transform 80ms ease, background 120ms ease;
    }
    .btn:active{ transform: scale(.98); background: rgba(255,255,255,.18); }
    .btn.big{
      grid-column: 1 / -1;
      background: linear-gradient(90deg, rgba(255,120,230,.25), rgba(120,170,255,.22));
    }

    /* MODAL */
    .modal{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      background: rgba(0,0,0,.62);
      z-index: 50;
    }
    .modal.show{ display:flex; }
    .modalCard{
      width: min(520px, 100%);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.18);
      background: linear-gradient(180deg, rgba(30,20,60,.72), rgba(10,10,20,.75));
      box-shadow: 0 25px 90px rgba(0,0,0,.55);
      padding: 18px;
      text-align:center;
    }
    .modalCard h2{ margin: 6px 0 8px; font-size: 22px; }
    .modalCard p{ margin:0 0 14px; color: rgba(255,255,255,.82); font-size: 13px; line-height:1.4; }

    .rowBtns{
      display:flex; gap:10px; justify-content:center; flex-wrap:wrap;
    }
    .linkBtn{
      text-decoration:none;
      display:inline-flex; align-items:center; justify-content:center;
      padding: 12px 14px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.95);
      font-weight:800;
      font-size: 14px;
    }
    .linkBtn.primary{
      background: linear-gradient(90deg, rgba(255,120,230,.30), rgba(120,170,255,.28));
    }

    @media (max-width: 420px){
      .badge{ min-width: 140px; }
      .title h1{ font-size: 17px; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="panel">
      <div class="header">
        <div class="title">
          <h1>‚ú® K-Tetris</h1>
          <p>Completa <b>20 righe</b> per vincere. Dopo <b>10 righe</b> cambia lo sfondo üòé</p>
        </div>
        <div class="badge">
          <div class="pill" id="phasePill">Concept: 1 / 2</div>
          <div class="progress"><div class="bar" id="progressBar"></div></div>
        </div>
      </div>

      <div class="gameArea">
        <!-- Stage con sfondo SOLO dietro la griglia -->
        <div class="stage" aria-label="tetris-stage">
          <div class="gameBg" id="gameBg1"></div>
          <div class="gameBg alt" id="gameBg2"></div>
          <canvas id="game" width="300" height="600" aria-label="tetris"></canvas>
        </div>

        <div class="side">
          <div class="statGrid">
            <div class="stat"><div class="k">Punteggio</div><div class="v" id="score">0</div></div>
            <div class="stat"><div class="k">Righe</div><div class="v" id="lines">0 / 20</div></div>
            <div class="stat"><div class="k">Livello</div><div class="v" id="level">1</div></div>
            <div class="stat"><div class="k">Record</div><div class="v" id="best">0</div></div>
          </div>

          <div class="hint">
            <b>Controlli</b><br/>
            ‚Ä¢ Swipe: sinistra/destra<br/>
            ‚Ä¢ Swipe gi√π: scendi veloce<br/>
            ‚Ä¢ Tap: ruota<br/>
            ‚Ä¢ Bottoni qui sotto üëá
          </div>

          <div class="controls">
            <div class="btn" id="leftBtn">‚óÄÔ∏é</div>
            <div class="btn" id="rotateBtn">‚ü≥</div>
            <div class="btn" id="rightBtn">‚ñ∂Ô∏é</div>
            <div class="btn" id="downBtn">‚ñº</div>
            <div class="btn" id="dropBtn">‚¨áÔ∏é‚¨áÔ∏é</div>
            <div class="btn" id="pauseBtn">‚è∏Ô∏é</div>
            <div class="btn big" id="restartBtn">‚Üª Ricomincia</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- WIN MODAL -->
  <div class="modal" id="winModal" role="dialog" aria-modal="true">
    <div class="modalCard">
      <div class="pill" style="display:inline-block">üåü VITTORIA üåü</div>
      <h2>Hai completato 20 righe!</h2>
      <p>Premio sbloccato üéÅ</p>
      <div class="rowBtns">
        <a class="linkBtn primary" href="premio.html">Vai al premio</a>
        <a class="linkBtn" href="#" id="playAgain">Gioca ancora</a>
      </div>
    </div>
  </div>

  <!-- PAUSE MODAL -->
  <div class="modal" id="pauseModal" role="dialog" aria-modal="true">
    <div class="modalCard">
      <div class="pill" style="display:inline-block">‚è∏Ô∏é Pausa</div>
      <h2>In pausa</h2>
      <p>Tocca ‚ÄúRiprendi‚Äù per continuare.</p>
      <div class="rowBtns">
        <a class="linkBtn primary" href="#" id="resumeBtn">Riprendi</a>
        <a class="linkBtn" href="#" id="restartBtn2">Ricomincia</a>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const COLS = 10, ROWS = 20;
      const TARGET_LINES = 20;
      const PHASE_SWITCH = 10;

      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      const scoreEl = document.getElementById('score');
      const linesEl = document.getElementById('lines');
      const levelEl = document.getElementById('level');
      const bestEl = document.getElementById('best');

      const phasePill = document.getElementById('phasePill');
      const progressBar = document.getElementById('progressBar');

      const bgA = document.getElementById('gameBg1');
      const bgB = document.getElementById('gameBg2');

      const winModal = document.getElementById('winModal');
      const pauseModal = document.getElementById('pauseModal');

      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');
      const rotateBtn = document.getElementById('rotateBtn');
      const downBtn = document.getElementById('downBtn');
      const dropBtn = document.getElementById('dropBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const restartBtn = document.getElementById('restartBtn');
      const playAgain = document.getElementById('playAgain');
      const resumeBtn = document.getElementById('resumeBtn');
      const restartBtn2 = document.getElementById('restartBtn2');

      const BLOCK = canvas.width / COLS;

      const colors = {
        I: 'rgba(120,170,255,.95)',
        O: 'rgba(255,220,120,.95)',
        T: 'rgba(255,120,230,.95)',
        S: 'rgba(130,255,190,.95)',
        Z: 'rgba(255,120,140,.95)',
        J: 'rgba(180,160,255,.95)',
        L: 'rgba(255,170,120,.95)',
        G: 'rgba(255,255,255,.18)'
      };

      function roundRect(x,y,w,h,r){
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.arcTo(x+w, y, x+w, y+h, r);
        ctx.arcTo(x+w, y+h, x, y+h, r);
        ctx.arcTo(x, y+h, x, y, r);
        ctx.arcTo(x, y, x+w, y, r);
        ctx.closePath();
      }

      function drawBlock(x, y, fill){
        const px = x*BLOCK, py = y*BLOCK;
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,.35)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetY = 4;
        ctx.fillStyle = fill;
        roundRect(px+2, py+2, BLOCK-4, BLOCK-4, 8);
        ctx.fill();
        ctx.restore();

        ctx.strokeStyle = 'rgba(255,255,255,.20)';
        ctx.lineWidth = 1;
        roundRect(px+2, py+2, BLOCK-4, BLOCK-4, 8);
        ctx.stroke();

        const grd = ctx.createLinearGradient(px, py, px, py+BLOCK);
        grd.addColorStop(0, 'rgba(255,255,255,.22)');
        grd.addColorStop(.5, 'rgba(255,255,255,.05)');
        grd.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grd;
        roundRect(px+3, py+3, BLOCK-6, (BLOCK-6)*.55, 7);
        ctx.fill();
      }

      const SHAPES = {
        I: [
          [0,0,0,0],
          [1,1,1,1],
          [0,0,0,0],
          [0,0,0,0]
        ],
        O: [
          [1,1],
          [1,1]
        ],
        T: [
          [0,1,0],
          [1,1,1],
          [0,0,0]
        ],
        S: [
          [0,1,1],
          [1,1,0],
          [0,0,0]
        ],
        Z: [
          [1,1,0],
          [0,1,1],
          [0,0,0]
        ],
        J: [
          [1,0,0],
          [1,1,1],
          [0,0,0]
        ],
        L: [
          [0,0,1],
          [1,1,1],
          [0,0,0]
        ]
      };
      const TYPES = Object.keys(SHAPES);

      function newBag(){
        const bag = TYPES.slice();
        for (let i=bag.length-1; i>0; i--){
          const j = Math.floor(Math.random()*(i+1));
          [bag[i], bag[j]] = [bag[j], bag[i]];
        }
        return bag;
      }

      let board, bag, current, next, dropCounter, dropInterval, lastTime;
      let score, lines, level, paused, gameOver, won;

      const BEST_KEY = 'k_tetris_best';
      bestEl.textContent = String(Number(localStorage.getItem(BEST_KEY) || 0));

      function reset(){
        board = Array.from({length: ROWS}, () => Array(COLS).fill(null));
        bag = newBag();
        current = spawn();
        next = spawn(true);
        dropCounter = 0;
        dropInterval = 900;
        lastTime = 0;

        score = 0;
        lines = 0;
        level = 1;
        paused = false;
        gameOver = false;
        won = false;

        hideModals();
        setPhaseVisual();
        updateUI();
        draw();
      }

      function spawn(isNext=false){
        if (bag.length === 0) bag = newBag();
        const type = bag.pop();
        const shape = SHAPES[type].map(r => r.slice());
        const piece = { type, shape, x: Math.floor((COLS - shape[0].length)/2), y: -1 };
        if (!isNext && collide(piece, board)) gameOver = true;
        return piece;
      }

      function rotate(matrix){
        const N = matrix.length;
        const res = Array.from({length:N}, () => Array(N).fill(0));
        for(let y=0;y<N;y++) for(let x=0;x<N;x++) res[x][N-1-y] = matrix[y][x];
        return res;
      }
      function trim(mat){
        let top=0, bottom=mat.length-1, left=0, right=mat[0].length-1;
        const rowEmpty = (r)=> mat[r].every(v=>v===0);
        const colEmpty = (c)=> mat.every(row=>row[c]===0);
        while(top<=bottom && rowEmpty(top)) top++;
        while(bottom>=top && rowEmpty(bottom)) bottom--;
        while(left<=right && colEmpty(left)) left++;
        while(right>=left && colEmpty(right)) right--;
        const res = [];
        for(let r=top;r<=bottom;r++) res.push(mat[r].slice(left, right+1));
        return res.length ? res : [[0]];
      }

      function rotatePiece(){
        if (paused || gameOver || won) return;
        const shape = current.shape;
        let rotated;
        if (shape.length !== shape[0].length){
          const n = Math.max(shape.length, shape[0].length);
          const sq = Array.from({length:n}, (_,r)=>Array.from({length:n},(_,c)=> (shape[r]?.[c]||0)));
          rotated = trim(rotate(sq));
        } else rotated = trim(rotate(shape));

        const test = {...current, shape: rotated};
        const kicks = [0, -1, 1, -2, 2];
        for (const k of kicks){
          const moved = {...test, x: test.x + k};
          if (!collide(moved, board)){
            current.shape = rotated;
            current.x = moved.x;
            return;
          }
        }
      }

      function collide(piece, b){
        const {shape, x:px, y:py} = piece;
        for(let y=0;y<shape.length;y++){
          for(let x=0;x<shape[y].length;x++){
            if (!shape[y][x]) continue;
            const bx = px + x, by = py + y;
            if (bx < 0 || bx >= COLS || by >= ROWS) return true;
            if (by >= 0 && b[by][bx]) return true;
          }
        }
        return false;
      }

      function merge(){
        const {shape, x:px, y:py, type} = current;
        for(let y=0;y<shape.length;y++){
          for(let x=0;x<shape[y].length;x++){
            if (!shape[y][x]) continue;
            const bx = px + x, by = py + y;
            if (by >= 0 && by < ROWS && bx >=0 && bx < COLS) board[by][bx] = type;
          }
        }
      }

      function clearLines(){
        let cleared = 0;
        outer: for (let y=ROWS-1; y>=0; y--){
          for(let x=0;x<COLS;x++) if(!board[y][x]) continue outer;
          board.splice(y,1);
          board.unshift(Array(COLS).fill(null));
          cleared++; y++;
        }
        if (cleared){
          const points = [0, 100, 300, 500, 800][cleared] || (cleared*250);
          score += points * level;
          lines += cleared;

          level = 1 + Math.floor(lines / 5);
          dropInterval = Math.max(140, 900 - (level-1)*80);

          if (lines >= PHASE_SWITCH) setPhaseVisual(true);
          if (lines >= TARGET_LINES){ won = true; showWin(); }
        }
      }

      function move(dx){
        if (paused || gameOver || won) return;
        const test = {...current, x: current.x + dx};
        if (!collide(test, board)) current.x += dx;
      }

      function softDrop(){
        if (paused || gameOver || won) return;
        const test = {...current, y: current.y + 1};
        if (!collide(test, board)){
          current.y++; score += 1;
        } else {
          merge(); clearLines();
          current = next; next = spawn(true);
          if (collide(current, board)) gameOver = true;
        }
      }

      function hardDrop(){
        if (paused || gameOver || won) return;
        let d = 0;
        while(!collide({...current, y: current.y + 1}, board)){ current.y++; d++; }
        score += d * 2;
        softDrop();
      }

      function drawBoard(){
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // leggero grid
        ctx.fillStyle = 'rgba(255,255,255,.035)';
        for(let y=0;y<ROWS;y++){
          for(let x=0;x<COLS;x++){
            const px=x*BLOCK, py=y*BLOCK;
            ctx.fillRect(px+1, py+1, BLOCK-2, BLOCK-2);
          }
        }

        for(let y=0;y<ROWS;y++){
          for(let x=0;x<COLS;x++){
            const t = board[y][x];
            if (t) drawBlock(x,y, colors[t]);
          }
        }
      }

      function ghostPiece(){
        const g = JSON.parse(JSON.stringify(current));
        while(!collide({...g, y: g.y + 1}, board)) g.y++;
        return g;
      }
      function drawPiece(piece, asGhost=false){
        const {shape, x:px, y:py, type} = piece;
        const fill = asGhost ? colors.G : colors[type];
        for(let y=0;y<shape.length;y++){
          for(let x=0;x<shape[y].length;x++){
            if(!shape[y][x]) continue;
            const bx = px + x, by = py + y;
            if (by >= 0) drawBlock(bx, by, fill);
          }
        }
      }

      function draw(){
        drawBoard();
        if (!gameOver){
          drawPiece(ghostPiece(), true);
          drawPiece(current, false);
        }
      }

      function updateUI(){
        scoreEl.textContent = String(score);
        linesEl.textContent = `${Math.min(lines, TARGET_LINES)} / ${TARGET_LINES}`;
        levelEl.textContent = String(level);

        const pct = Math.min(100, (lines / TARGET_LINES) * 100);
        progressBar.style.width = pct + '%';

        bestEl.textContent = String(Number(localStorage.getItem(BEST_KEY) || 0));
      }

      function setPhaseVisual(){
        const concept = (lines >= PHASE_SWITCH) ? 2 : 1;
        phasePill.textContent = `Concept: ${concept} / 2`;
        if (concept === 2){ bgB.style.opacity = '1'; bgA.style.opacity = '0'; }
        else { bgB.style.opacity = '0'; bgA.style.opacity = '1'; }
      }

      function showWin(){
        const bestNow = Number(localStorage.getItem(BEST_KEY) || 0);
        if (score > bestNow) localStorage.setItem(BEST_KEY, String(score));
        updateUI();
        winModal.classList.add('show');
      }

      function togglePause(){
        if (gameOver || won) return;
        paused = !paused;
        pauseModal.classList.toggle('show', paused);
      }

      function hideModals(){
        winModal.classList.remove('show');
        pauseModal.classList.remove('show');
      }

      function update(time=0){
        const delta = time - lastTime;
        lastTime = time;

        if (!paused && !gameOver && !won){
          dropCounter += delta;
          if (dropCounter > dropInterval){
            softDrop();
            dropCounter = 0;
            updateUI();
          }
        }
        draw();
        requestAnimationFrame(update);
      }

      // Keyboard (desktop)
      window.addEventListener('keydown', (e)=>{
        if (e.key === 'ArrowLeft') move(-1);
        else if (e.key === 'ArrowRight') move(1);
        else if (e.key === 'ArrowDown') softDrop();
        else if (e.key === 'ArrowUp') rotatePiece();
        else if (e.key === ' ') hardDrop();
        else if (e.key.toLowerCase() === 'p') togglePause();
        updateUI();
      });

      function bindButton(el, fn){
        el.addEventListener('click', (ev)=>{ ev.preventDefault(); fn(); updateUI(); }, {passive:false});
        el.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); fn(); updateUI(); }, {passive:false});
      }
      bindButton(leftBtn, ()=>move(-1));
      bindButton(rightBtn, ()=>move(1));
      bindButton(rotateBtn, rotatePiece);
      bindButton(downBtn, softDrop);
      bindButton(dropBtn, hardDrop);
      bindButton(pauseBtn, togglePause);
      bindButton(restartBtn, reset);

      playAgain.addEventListener('click', (e)=>{ e.preventDefault(); reset(); }, {passive:false});
      resumeBtn.addEventListener('click', (e)=>{ e.preventDefault(); togglePause(); }, {passive:false});
      restartBtn2.addEventListener('click', (e)=>{ e.preventDefault(); reset(); }, {passive:false});

      // Touch gestures sul canvas
      let touchStartX=0, touchStartY=0, touchStartT=0, moved=false;

      canvas.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        const t = e.changedTouches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchStartT = Date.now();
        moved = false;
      }, {passive:false});

      canvas.addEventListener('touchmove', (e)=>{
        e.preventDefault();
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        const AX = Math.abs(dx), AY = Math.abs(dy);

        const threshold = 14;
        if (AX > threshold || AY > threshold) moved = true;

        if (AX > 28 && AX > AY){
          move(dx > 0 ? 1 : -1);
          touchStartX = t.clientX;
        }
        if (AY > 28 && AY > AX && dy > 0){
          softDrop();
          touchStartY = t.clientY;
        }
        updateUI();
      }, {passive:false});

      canvas.addEventListener('touchend', (e)=>{
        e.preventDefault();
        const dt = Date.now() - touchStartT;
        if (!moved && dt < 220){
          rotatePiece();
          updateUI();
        }
      }, {passive:false});

      // Start
      reset();
      requestAnimationFrame(update);
    })();
  </script>
</body>
</html>
