<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>K-Tetris</title>

<style>
:root{
  --txt: rgba(255,255,255,.92);
  --muted: rgba(255,255,255,.72);
  --stroke: rgba(255,255,255,.18);
  --shadow: 0 18px 60px rgba(0,0,0,.45);
  --radius: 18px;
}
*{ box-sizing:border-box; }
html,body{ height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto; color:var(--txt); }
body{
  background:#05040a;
  /* ‚úÖ NON tagliare pi√π: se serve, scroll */
  overflow:auto;
  -webkit-tap-highlight-color: transparent;
  touch-action: manipulation;
}

.wrap{
  min-height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:
    calc(12px + env(safe-area-inset-top))
    12px
    calc(12px + env(safe-area-inset-bottom))
    12px;
}

.panel{
  width:min(980px,100%);
  background: linear-gradient(180deg, rgba(20,16,40,.60), rgba(10,10,20,.60));
  border:1px solid var(--stroke);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);

  /* ‚úÖ massimo altezza visibile, niente ‚Äúsparizione‚Äù */
  max-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom) - 24px);
  overflow:auto;
}

.header{
  position:sticky; top:0; z-index:5; /* ‚úÖ se scrolla dentro, header resta visibile */
  display:flex;
  justify-content:space-between;
  gap:12px;
  padding:14px 14px 12px;
  border-bottom:1px solid rgba(255,255,255,.1);
  background: linear-gradient(90deg, rgba(255,120,230,.18), rgba(120,170,255,.16));
  border-top-left-radius: var(--radius);
  border-top-right-radius: var(--radius);
}
.title h1{ margin:0; font-size:18px; line-height:1.05; }
.title p{ margin:6px 0 0; font-size:12px; color:var(--muted); line-height:1.25; }

.badge{ min-width:160px; }
.pill{
  font-size:12px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.16);
  background: rgba(255,255,255,.06);
  white-space:nowrap;
}
.progress{
  margin-top:6px;
  height:10px;
  background: rgba(255,255,255,.08);
  border-radius:999px;
  overflow:hidden;
}
.bar{
  height:100%;
  width:0%;
  background: linear-gradient(90deg, rgba(255,120,230,.9), rgba(120,170,255,.9));
  transition: width .2s ease;
}

.gameArea{
  display:flex;
  gap:12px;
  padding:12px;
  flex-wrap:wrap;
  justify-content:center;
  align-items:flex-start;
}

/* ‚úÖ stage che si adatta anche all‚ÄôALTEZZA disponibile */
.stage{
  position:relative;
  /* prima era solo su larghezza; ora anche su altezza */
  height: min(66vh, 600px);
  aspect-ratio:10/20;
  width:auto;

  border-radius:14px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.14);
  flex: 0 0 auto;
}

.gameBg{
  position:absolute; inset:0;
  background-size:cover;
  background-position:center;
  transition:opacity .6s ease;
}
#bg1{ background-image:url("bg1.png"); }
#bg2{ background-image:url("bg2.png"); opacity:0; }

canvas{
  position:absolute; inset:0;
  width:100%; height:100%;
  background: rgba(0,0,0,.25);
}

/* ‚ú® Glow overlay */
.glow{
  position:absolute;
  inset:-20%;
  background:
    radial-gradient(circle at center,
      rgba(255,120,230,.45),
      rgba(120,170,255,.35),
      transparent 70%);
  opacity:0;
  pointer-events:none;
  mix-blend-mode: screen;
  transition: opacity .35s ease;
}
.stage.glow-on .glow{ opacity:1; }

.side{
  min-width:240px;
  max-width:320px;
  display:flex;
  flex-direction:column;
  gap:12px;
  flex: 1 1 260px;
}

.statGrid{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:10px;
}
.stat{
  padding:12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
}
.stat .k{ font-size:11px; color:var(--muted); }
.stat .v{ font-size:20px; font-weight:700; }

.controls{
  display:grid;
  grid-template-columns:1fr 1fr 1fr;
  gap:10px;
}
.btn{
  padding:12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.18);
  background: rgba(255,255,255,.12);
  font-weight:700;
  text-align:center;
  user-select:none;
  -webkit-user-select:none;
}
.btn:active{ background: rgba(255,255,255,.18); }
.btn.big{ grid-column:1/-1; }

.modal{
  position:fixed; inset:0;
  background: rgba(0,0,0,.65);
  display:none;
  align-items:center;
  justify-content:center;
  padding:16px;
}
.modal.show{ display:flex; }
.modalCard{
  width:min(520px,100%);
  background:#120e2a;
  border-radius:20px;
  padding:18px;
  text-align:center;
  border:1px solid rgba(255,255,255,.18);
}
.modalCard h2{ margin:0 0 8px; }
.modalCard p{ margin:0 0 14px; color:var(--muted); }

/* ‚úÖ su schermi bassi o stretti: tutto in colonna (niente tagli) */
@media (max-width: 720px), (max-height: 720px){
  .gameArea{ flex-direction:column; align-items:center; }
  .side{ min-width:0; width:100%; max-width:520px; }
  .stage{ height: min(56vh, 520px); }
}
</style>
</head>

<body>
<div class="wrap">
  <div class="panel">
    <div class="header">
      <div class="title">
        <h1>‚ú® K-Tetris</h1>
        <p>Livello a ogni riga ‚Ä¢ Sfondo ogni 5 ‚Ä¢ Vinci a 10 üéÅ</p>
      </div>
      <div class="badge">
        <div class="pill" id="phasePill">Concept 1</div>
        <div class="progress"><div class="bar" id="progressBar"></div></div>
      </div>
    </div>

    <div class="gameArea">
      <div class="stage" id="stage">
        <div class="gameBg" id="bg1"></div>
        <div class="gameBg" id="bg2"></div>
        <div class="glow"></div>
        <canvas id="game" width="300" height="600"></canvas>
      </div>

      <div class="side">
        <div class="statGrid">
          <div class="stat"><div class="k">Righe</div><div class="v" id="lines">0 / 10</div></div>
          <div class="stat"><div class="k">Livello</div><div class="v" id="level">1</div></div>
        </div>

        <div class="controls">
          <div class="btn" id="leftBtn">‚óÄÔ∏é</div>
          <div class="btn" id="rotateBtn">‚ü≥</div>
          <div class="btn" id="rightBtn">‚ñ∂Ô∏é</div>
          <div class="btn" id="downBtn">‚ñº</div>
          <div class="btn" id="dropBtn">‚¨áÔ∏é‚¨áÔ∏é</div>
          <div class="btn big" id="restartBtn">‚Üª Restart</div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="modal" id="winModal">
  <div class="modalCard">
    <h2>üåü VITTORIA üåü</h2>
    <p>Hai completato 10 righe!</p>
    <div class="controls" style="grid-template-columns:1fr; max-width:320px; margin:0 auto;">
      <a href="premio.html" class="btn" style="text-decoration:none; color:var(--txt); display:block;">Vai al premio</a>
      <div class="btn" id="playAgainBtn">Gioca ancora</div>
    </div>
  </div>
</div>

<script>
(() => {
  const COLS=10, ROWS=20;
  const TARGET_LINES=10;
  const BG_STEP=5;

  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');

  const stage=document.getElementById('stage');
  const bg1=document.getElementById('bg1');
  const bg2=document.getElementById('bg2');

  const linesEl=document.getElementById('lines');
  const levelEl=document.getElementById('level');
  const bar=document.getElementById('progressBar');
  const phasePill=document.getElementById('phasePill');
  const winModal=document.getElementById('winModal');

  const leftBtn=document.getElementById('leftBtn');
  const rightBtn=document.getElementById('rightBtn');
  const downBtn=document.getElementById('downBtn');
  const dropBtn=document.getElementById('dropBtn');
  const rotateBtn=document.getElementById('rotateBtn');
  const restartBtn=document.getElementById('restartBtn');
  const playAgainBtn=document.getElementById('playAgainBtn');

  const SHAPES=[
    [[1,1,1,1]],
    [[1,1],[1,1]],
    [[0,1,0],[1,1,1]],
    [[1,1,0],[0,1,1]],
    [[0,1,1],[1,1,0]],
    [[1,0,0],[1,1,1]],
    [[0,0,1],[1,1,1]]
  ];

  // canvas ‚Äúlogico‚Äù: fisso a 300x600, poi CSS lo scala
  const BLOCK = canvas.width / COLS;

  let board, piece, lines=0, level=1;
  let dropInterval=900, lastTime=0, dropCounter=0, won=false;
  let currentPhase = 0; // ‚úÖ per capire quando cambia sfondo

  function haptic(ms=18){
    if (navigator.vibrate) navigator.vibrate(ms);
  }
  function glow(){
    stage.classList.add('glow-on');
    setTimeout(()=>stage.classList.remove('glow-on'), 280);
  }

  function reset(){
    board=Array.from({length:ROWS},()=>Array(COLS).fill(0));
    piece=newPiece();
    lines=0; level=1; won=false;
    currentPhase = 0;
    winModal.classList.remove('show');
    updateProgression(true);
  }

  function newPiece(){
    const s=SHAPES[Math.floor(Math.random()*SHAPES.length)];
    return {shape:s.map(r=>r.slice()), x:3, y:0};
  }

  function collide(p){
    return p.shape.some((r,y)=>r.some((v,x)=>{
      if(!v) return false;
      const nx = p.x + x;
      const ny = p.y + y;
      if(nx<0 || nx>=COLS || ny>=ROWS) return true;
      if(ny>=0 && board[ny][nx]) return true;
      return false;
    }));
  }

  function merge(){
    piece.shape.forEach((r,y)=>r.forEach((v,x)=>{
      if(!v) return;
      const ny = piece.y+y;
      const nx = piece.x+x;
      if(ny>=0 && ny<ROWS && nx>=0 && nx<COLS) board[ny][nx]=1;
    }));
  }

  function rotatePiece(){
    // rotazione semplice (matrice)
    const m = piece.shape;
    const h = m.length, w = m[0].length;
    const rotated = Array.from({length:w}, (_,x)=>Array.from({length:h}, (_,y)=>m[h-1-y][x]));
    const test = {...piece, shape: rotated};

    // wall kick base
    const kicks=[0,-1,1,-2,2];
    for(const k of kicks){
      const moved = {...test, x: test.x + k};
      if(!collide(moved)){ piece = moved; return; }
    }
  }

  function clearFullLines(){
    let clearedNow = 0;
    for(let y=ROWS-1; y>=0; y--){
      if(board[y].every(v=>v===1)){
        board.splice(y,1);
        board.unshift(Array(COLS).fill(0));
        clearedNow++;
        y++;
      }
    }
    if(clearedNow){
      lines += clearedNow;
      updateProgression(false);
      if(lines >= TARGET_LINES){
        won = true;
        winModal.classList.add('show');
      }
    }
  }

  function updateProgression(isInitial){
    // livello a ogni riga
    level = lines + 1;
    dropInterval = Math.max(140, 900 - (level - 1) * 70);

    const phase = Math.floor(lines / BG_STEP); // 0,1,2...
    phasePill.textContent = `Concept ${phase + 1}`;

    // ‚úÖ cambia sfondo SOLO quando cambia phase
    if(isInitial){
      currentPhase = phase;
      bg1.style.opacity = (phase % 2 === 0) ? 1 : 0;
      bg2.style.opacity = (phase % 2 === 0) ? 0 : 1;
    } else if(phase !== currentPhase){
      currentPhase = phase;
      bg1.style.opacity = (phase % 2 === 0) ? 1 : 0;
      bg2.style.opacity = (phase % 2 === 0) ? 0 : 1;

      glow();
      haptic(22);
    }

    linesEl.textContent = `${Math.min(lines, TARGET_LINES)} / ${TARGET_LINES}`;
    levelEl.textContent = `${level}`;
    bar.style.width = Math.min(100, (lines / TARGET_LINES) * 100) + '%';
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // griglia leggera
    ctx.fillStyle = 'rgba(255,255,255,.06)';
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        ctx.fillRect(x*BLOCK+1,y*BLOCK+1,BLOCK-2,BLOCK-2);
      }
    }

    // blocchi fissati
    ctx.fillStyle = 'rgba(255,255,255,.90)';
    board.forEach((r,y)=>r.forEach((v,x)=>{
      if(v) ctx.fillRect(x*BLOCK+2,y*BLOCK+2,BLOCK-4,BLOCK-4);
    }));

    // pezzo corrente
    ctx.fillStyle = 'rgba(255,120,230,.95)';
    piece.shape.forEach((r,y)=>r.forEach((v,x)=>{
      if(!v) return;
      const px = (piece.x+x)*BLOCK;
      const py = (piece.y+y)*BLOCK;
      ctx.fillRect(px+2,py+2,BLOCK-4,BLOCK-4);
    }));
  }

  function step(time=0){
    if(won) return;
    const dt = time - lastTime;
    lastTime = time;
    dropCounter += dt;

    if(dropCounter > dropInterval){
      piece.y++;
      if(collide(piece)){
        piece.y--;
        merge();
        clearFullLines();
        piece = newPiece();
        if(collide(piece)){ reset(); } // safety
      }
      dropCounter = 0;
    }

    draw();
    requestAnimationFrame(step);
  }

  // controlli
  leftBtn.onclick=()=>{ piece.x--; if(collide(piece)) piece.x++; };
  rightBtn.onclick=()=>{ piece.x++; if(collide(piece)) piece.x--; };
  downBtn.onclick=()=>{ piece.y++; if(collide(piece)) piece.y--; };
  dropBtn.onclick=()=>{ while(!collide(piece)) piece.y++; piece.y--; };
  rotateBtn.onclick=()=>rotatePiece();
  restartBtn.onclick=()=>reset();
  playAgainBtn.onclick=()=>reset();

  // touch swipe semplice su canvas
  let sx=0, sy=0, moved=false;
  canvas.addEventListener('touchstart',(e)=>{
    const t=e.changedTouches[0];
    sx=t.clientX; sy=t.clientY; moved=false;
  }, {passive:true});
  canvas.addEventListener('touchmove',(e)=>{
    const t=e.changedTouches[0];
    const dx=t.clientX-sx, dy=t.clientY-sy;
    if(Math.abs(dx)>18 || Math.abs(dy)>18) moved=true;

    if(Math.abs(dx)>28 && Math.abs(dx)>Math.abs(dy)){
      (dx>0 ? rightBtn : leftBtn).onclick();
      sx=t.clientX;
    }
    if(dy>28 && Math.abs(dy)>Math.abs(dx)){
      downBtn.onclick();
      sy=t.clientY;
    }
  }, {passive:true});
  canvas.addEventListener('touchend',()=>{
    if(!moved) rotatePiece(); // tap = rotate
  }, {passive:true});

  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
